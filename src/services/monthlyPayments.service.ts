// src/services/monthlyPayments.service.ts
// VERSIÓN CORREGIDA CON ACTUALIZACIÓN DE DEUDA

import {
  collection,
  doc,
  getDoc,
  getDocs,
  setDoc,
  updateDoc,
  query,
  where,
  Timestamp,
  runTransaction,
  orderBy
} from 'firebase/firestore';
import { db } from '../config/firebase';
import {
  MonthlyPayment,
  MembershipStatus,
  MonthlySummary,
  MonthlyPaymentListItem,
  AutoGenerationResult,
  PaymentMethod
} from '../types/monthlyPayments.types';

const getCurrentMonth = (): string => {
  const now = new Date();
  const year = now.getFullYear();
  const month = String(now.getMonth() + 1).padStart(2, '0');
  return `${year}-${month}`;
};

const getDueDate = (monthStr: string): string => {
  return `${monthStr}-15`;
};

const paymentExists = async (
  gymId: string,
  memberId: string,
  membershipId: string,
  month: string
): Promise<boolean> => {
  const paymentId = `${month}-${memberId}-${membershipId}`;
  const paymentRef = doc(db, `gyms/${gymId}/monthlyPayments`, paymentId);
  const paymentSnap = await getDoc(paymentRef);
  return paymentSnap.exists();
};

const isOverdue = (dueDate: string): boolean => {
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  const due = new Date(dueDate);
  return today > due;
};

export const generateMonthlyPayments = async (
  gymId: string
): Promise<AutoGenerationResult> => {
  const result: AutoGenerationResult = {
    success: false,
    paymentsGenerated: 0,
    errors: [],
    summary: {
      totalMembers: 0,
      totalMemberships: 0,
      totalAmount: 0,
      skipped: {
        suspended: 0,
        alreadyExists: 0
      }
    }
  };

  try {
    const currentMonth = getCurrentMonth();
    const today = new Date();

    console.log(`Generando pagos para ${currentMonth}...`);

    const membersRef = collection(db, `gyms/${gymId}/members`);
    const membersSnap = await getDocs(membersRef);

    result.summary.totalMembers = membersSnap.size;

    for (const memberDoc of membersSnap.docs) {
      const memberId = memberDoc.id;
      const memberData = memberDoc.data();
      const memberName = `${memberData.firstName} ${memberData.lastName}`;

      if (memberData.status !== 'active') continue;

      const membershipsRef = collection(
        db,
        `gyms/${gymId}/members/${memberId}/memberships`
      );
      const membershipsSnap = await getDocs(membershipsRef);

      for (const membershipDoc of membershipsSnap.docs) {
        const membership = membershipDoc.data() as MembershipStatus;
        const membershipId = membershipDoc.id;

        result.summary.totalMemberships++;

        if (membership.status === 'suspended') {
          result.summary.skipped.suspended++;
          continue;
        }

        if (!membership.autoGeneratePayments) {
          continue;
        }

        let targetMonth = currentMonth;

        const startDate = new Date(membership.startDate);
        const startDay = startDate.getDate();

        if (startDay > 15) {
          const nextMonth = new Date(startDate);
          nextMonth.setMonth(nextMonth.getMonth() + 1);
          const year = nextMonth.getFullYear();
          const month = String(nextMonth.getMonth() + 1).padStart(2, '0');
          targetMonth = `${year}-${month}`;
        }

        const exists = await paymentExists(
          gymId,
          memberId,
          membershipId,
          targetMonth
        );

        if (exists) {
          result.summary.skipped.alreadyExists++;
          continue;
        }

        // OBTENER PRECIO DE LA MEMBERSHIP (no de la actividad)
        const membershipDefRef = collection(db, `gyms/${gymId}/memberships`);
        const membershipDefQuery = query(
          membershipDefRef,
          where('activityId', '==', membership.activityId)
        );
        const membershipDefSnap = await getDocs(membershipDefQuery);

        let currentPrice = 0;
        
        if (!membershipDefSnap.empty) {
          const membershipDefData = membershipDefSnap.docs[0].data();
          currentPrice = membershipDefData.cost || 0;
          console.log(`Precio obtenido: ${membership.activityName} = $${currentPrice}`);
        } else {
          console.warn(`No se encontró definición de membership para ${membership.activityName}`);
          continue;
        }

        const payment: MonthlyPayment = {
          memberId,
          memberName,
          membershipId,
          activityId: membership.activityId,
          activityName: membership.activityName,
          month: targetMonth,
          dueDate: getDueDate(targetMonth),
          amount: currentPrice,
          status: 'pending',
          autoGenerated: true,
          generatedAt: Timestamp.now()
        };

        const paymentId = `${targetMonth}-${memberId}-${membershipId}`;
        const paymentRef = doc(db, `gyms/${gymId}/monthlyPayments`, paymentId);

        await setDoc(paymentRef, payment);

        // ACTUALIZAR DEUDA DEL SOCIO
        const memberRef = doc(db, `gyms/${gymId}/members`, memberId);
        const memberSnap = await getDoc(memberRef);

        if (memberSnap.exists()) {
          const currentMemberData = memberSnap.data();
          const currentDebt = currentMemberData.totalDebt || 0;
          
          await updateDoc(memberRef, {
            totalDebt: currentDebt + currentPrice,
            updatedAt: Timestamp.now()
          });
          
          console.log(`Deuda actualizada: ${memberName} +$${currentPrice} (Total: $${currentDebt + currentPrice})`);
        }

        result.paymentsGenerated++;
        result.summary.totalAmount += currentPrice;

        console.log(`Pago generado: ${memberName} - ${membership.activityName} - $${currentPrice}`);
      }
    }

    result.success = true;
    console.log('Generación completa:', result);
    return result;

  } catch (error: any) {
    console.error('Error generando pagos:', error);
    result.errors.push(error.message);
    return result;
  }
};

export const getPendingPaymentsList = async (
  gymId: string,
  month?: string
): Promise<MonthlyPaymentListItem[]> => {
  try {
    const targetMonth = month || getCurrentMonth();

    // 1. Obtener todos los pagos pendientes del mes
    const paymentsRef = collection(db, `gyms/${gymId}/monthlyPayments`);
    const q = query(
      paymentsRef,
      where('month', '==', targetMonth),
      orderBy('memberName')
    );

    const paymentsSnap = await getDocs(q);

    // 2. Agrupar por socio y obtener su información
    const memberPayments: Map<string, MonthlyPaymentListItem> = new Map();
    const memberIds: Set<string> = new Set();

    paymentsSnap.forEach((doc) => {
      const payment = doc.data() as MonthlyPayment;

      if (payment.status === 'paid') return;

      memberIds.add(payment.memberId);

      const overdue = isOverdue(payment.dueDate);
      const status = overdue ? 'overdue' : 'pending';

      if (!memberPayments.has(payment.memberId)) {
        memberPayments.set(payment.memberId, {
          memberId: payment.memberId,
          memberName: payment.memberName,
          totalPending: 0,
          activitiesPendingCount: 0,
          isOverdue: overdue,
          daysOverdue: 0,
          pendingActivities: []
        });
      }

      const item = memberPayments.get(payment.memberId)!;
      item.totalPending += payment.amount;
      item.activitiesPendingCount++;

      if (overdue) {
        const today = new Date();
        const due = new Date(payment.dueDate);
        const days = Math.floor(
          (today.getTime() - due.getTime()) / (1000 * 60 * 60 * 24)
        );
        item.daysOverdue = Math.max(item.daysOverdue, days);
      }

      item.pendingActivities.push({
        paymentId: doc.id,
        membershipId: payment.membershipId,
        activityName: payment.activityName,
        amount: payment.amount,
        dueDate: payment.dueDate,
        status
      });
    });

    // 3. Obtener información completa de cada socio (TELÉFONO, EMAIL, NOTIFICACIONES)
    const enrichedPayments: MonthlyPaymentListItem[] = [];

    // ✅ CORREGIDO: Convertir Set a Array antes de iterar
    const memberIdsArray = Array.from(memberIds);
    
    for (let i = 0; i < memberIdsArray.length; i++) {
      const memberId = memberIdsArray[i];
      const memberRef = doc(db, `gyms/${gymId}/members`, memberId);
      const memberSnap = await getDoc(memberRef);

      const paymentItem = memberPayments.get(memberId)!;

      if (memberSnap.exists()) {
        const memberData = memberSnap.data();
        
        // Agregar información del socio
        paymentItem.memberPhone = memberData.phone || null;
        paymentItem.memberEmail = memberData.email || null;
        
        // Agregar información de notificaciones
        paymentItem.lastNotifiedAt = memberData.lastDebtNotification || null;
        paymentItem.notificationCount = memberData.debtNotificationCount || 0;
      }

      enrichedPayments.push(paymentItem);
    }

    // 4. Ordenar: primero vencidos, luego por nombre
    return enrichedPayments.sort((a, b) => {
      if (a.isOverdue && !b.isOverdue) return -1;
      if (!a.isOverdue && b.isOverdue) return 1;
      return a.memberName.localeCompare(b.memberName);
    });

  } catch (error) {
    console.error('Error obteniendo lista de pagos:', error);
    throw error;
  }
};

export const getMonthlySummary = async (
  gymId: string,
  month?: string
): Promise<MonthlySummary> => {
  try {
    const targetMonth = month || getCurrentMonth();
    const [year, monthNum] = targetMonth.split('-').map(Number);

    const paymentsRef = collection(db, `gyms/${gymId}/monthlyPayments`);
    const q = query(paymentsRef, where('month', '==', targetMonth));
    const paymentsSnap = await getDocs(q);

    const summary: MonthlySummary = {
      year,
      month: monthNum,
      totalMembers: 0,
      totalToCollect: 0,
      totalCollected: 0,
      totalPending: 0,
      membersWithDebt: 0,
      membersUpToDate: 0,
      activitiesBreakdown: {}
    };

    const membersSet = new Set<string>();
    const membersWithDebtSet = new Set<string>();

    paymentsSnap.forEach((doc) => {
      const payment = doc.data() as MonthlyPayment;

      membersSet.add(payment.memberId);
      summary.totalToCollect += payment.amount;

      if (payment.status === 'paid') {
        summary.totalCollected += payment.amount;
      } else {
        summary.totalPending += payment.amount;
        membersWithDebtSet.add(payment.memberId);
      }

      if (!summary.activitiesBreakdown[payment.activityName]) {
        summary.activitiesBreakdown[payment.activityName] = {
          members: 0,
          totalCost: 0,
          collected: 0,
          pending: 0
        };
      }

      const breakdown = summary.activitiesBreakdown[payment.activityName];
      breakdown.members++;
      breakdown.totalCost += payment.amount;

      if (payment.status === 'paid') {
        breakdown.collected += payment.amount;
      } else {
        breakdown.pending += payment.amount;
      }
    });

    summary.totalMembers = membersSet.size;
    summary.membersWithDebt = membersWithDebtSet.size;
    summary.membersUpToDate = summary.totalMembers - summary.membersWithDebt;

    return summary;

  } catch (error) {
    console.error('Error obteniendo resumen mensual:', error);
    throw error;
  }
};

export const registerPayment = async (
  gymId: string,
  paymentId: string,
  paymentMethod: PaymentMethod,
  transactionId?: string
): Promise<{ success: boolean; error?: string }> => {
  try {
    await runTransaction(db, async (transaction) => {
      // 1️⃣ TODAS LAS LECTURAS PRIMERO
      const paymentRef = doc(db, `gyms/${gymId}/monthlyPayments`, paymentId);
      const paymentSnap = await transaction.get(paymentRef);

      if (!paymentSnap.exists()) {
        throw new Error('Pago no encontrado');
      }

      const payment = paymentSnap.data() as MonthlyPayment;

      if (payment.status === 'paid') {
        throw new Error('Este pago ya fue registrado');
      }

      // Leer datos del socio ANTES de escribir
      const memberRef = doc(db, `gyms/${gymId}/members`, payment.memberId);
      const memberSnap = await transaction.get(memberRef);

      if (!memberSnap.exists()) {
        throw new Error('Socio no encontrado');
      }

      const memberData = memberSnap.data();
      const currentDebt = memberData.totalDebt || 0;
      const newDebt = Math.max(0, currentDebt - payment.amount);

      // 2️⃣ TODAS LAS ESCRITURAS DESPUÉS
      transaction.update(paymentRef, {
        status: 'paid',
        paidAt: Timestamp.now(),
        paidDate: new Date().toISOString().split('T')[0],
        transactionId: transactionId || null
      });

      transaction.update(memberRef, {
        totalDebt: newDebt,
        updatedAt: Timestamp.now()
      });

      console.log(`✅ Pago actualizado: ${payment.memberName} -$${payment.amount} (Nueva deuda: $${newDebt})`);
    });

    return { success: true };

  } catch (error: any) {
    console.error('❌ Error registrando pago:', error);
    return { success: false, error: error.message };
  }
};

export const createMembership = async (
  gymId: string,
  memberId: string,
  memberName: string,
  activityId: string,
  activityName: string,
  startDate: string
): Promise<{ success: boolean; membershipId?: string; error?: string }> => {
  try {
    const membershipData: MembershipStatus = {
      memberId,
      memberName,
      activityId,
      activityName,
      startDate,
      status: 'active',
      autoGeneratePayments: true,
      createdAt: Timestamp.now()
    };

    const membershipsRef = collection(
      db,
      `gyms/${gymId}/members/${memberId}/memberships`
    );
    const membershipRef = doc(membershipsRef);
    await setDoc(membershipRef, membershipData);

    await generateMonthlyPayments(gymId);

    return { success: true, membershipId: membershipRef.id };

  } catch (error: any) {
    console.error('Error creando membresía:', error);
    return { success: false, error: error.message };
  }
};

export const suspendMembership = async (
  gymId: string,
  memberId: string,
  membershipId: string,
  reason?: string
): Promise<{ success: boolean; error?: string }> => {
  try {
    const membershipRef = doc(
      db,
      `gyms/${gymId}/members/${memberId}/memberships`,
      membershipId
    );

    await updateDoc(membershipRef, {
      status: 'suspended',
      autoGeneratePayments: false,
      suspendedAt: Timestamp.now(),
      suspendedReason: reason || 'Sin motivo especificado',
      updatedAt: Timestamp.now()
    });

    return { success: true };

  } catch (error: any) {
    console.error('Error suspendiendo membresía:', error);
    return { success: false, error: error.message };
  }
};

export const reactivateMembership = async (
  gymId: string,
  memberId: string,
  membershipId: string
): Promise<{ success: boolean; error?: string }> => {
  try {
    const membershipRef = doc(
      db,
      `gyms/${gymId}/members/${memberId}/memberships`,
      membershipId
    );

    await updateDoc(membershipRef, {
      status: 'active',
      autoGeneratePayments: true,
      suspendedAt: null,
      suspendedReason: null,
      updatedAt: Timestamp.now()
    });

    await generateMonthlyPayments(gymId);

    return { success: true };

  } catch (error: any) {
    console.error('Error reactivando membresía:', error);
    return { success: false, error: error.message };
  }
};